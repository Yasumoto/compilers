\documentclass[10pt,letterpaper]{article}
\author{Joe Smith\\smith237@chapman.edu}
\title{\textbf{CPSC 402: Compiler Contruction\\Implementing Classes in Triangle}}
\usepackage{listings}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{color}
\lstset{frame=shadowbox, rulesepcolor=\color{blue}}
\begin{document}
\maketitle

\begin{abstract}
This paper details my experiences with extending the Triangle language with classes, followed by updating the implementation to become consistent with my design. After much trial, tribulation, and help from my professor and peers, I created a small yet functional vision of clases, one that implements both member variables and methods.
\end{abstract}

\section{Introduction}
Implementing support for classes is no walk in the park. Although I took many long walks working out my design, in the end I am glad to say that I feel accomplished with my semester-long project. Object-oriented programming is a familiar topic to most students and software engineers, it has been one of the dominant design paradigms since the 1990s. It allows for flexible and reuseable code, and also helps design software in a way that is similar to real life.

\section{Triangle Language Changes}
My triangle language extension is to add classes to Triangle. I implemented two different additions, both of which are neccesary to fully integrate classes into the language. The first is the Class Type Denoter, which is used to declare the methods and member variables of a class, as well as the Method Call Command, which is used in order to actually call methods of an object. 
\subsection{Syntax}

My actual syntax for the command is

\begin{lstlisting}
ClassTypeDenoter
   ::= type Identifier ~ class
          Declaration
       end;
\end{lstlisting}

and the notation for the Method Call Command is as follows:

\begin{lstlisting}
MethodCallCommand 
   ::= Identifier-Identifier( Actual-Parameter-Sequence )
\end{lstlisting}

Deciding to use the Declaration was the saving idea of this project. After running through multiple implementation ideas with Dr. Radenski, we settled on using the Declaration, which would give us access to variables and methods, both of which I deemed neccesary to any reasonable implementation. This turned out to be much simpler than trying to manually adding in a Vname and a Proc AST.

\subsection{Semantics}
Currently, my implementation only allows for methods to access member variables (the infamous 'get' and 'set' methods). I deemed this to be keeping with the older, more restricted version of classes, one in which all variables are private. For the ClassTypeDenoter, the declaration can be any valid series of declarations, whether they are procedures, functions, constants, types, or variables.
\subsection{Examples}
The following is my example code, and prints out the number seven to the screen upon compilation and subsequent interpretation:

\begin{lstlisting}
let
     type apple ~ class
       var color : Integer;
       proc setColor (setTo : Integer) ~ color := setTo;
       proc printColor () ~ putint(color)

       end;

     var y : apple
in
     begin
       y-setColor (7);
       y-printColor ()
     end
\end{lstlisting}


\lstset{language=Java}%, caption=Descriptive Caption Text, label=DescriptiveLabel}

\section{Triangle Implementation Changes}
\subsection{Scanner, Parser, and Abstract Syntax Trees}
A large portion of my time was spent working with the Syntactic Analyzer. This was done concurrently with my attempts to build the proper language design, in this case my ideas for the design were closely linked to the actual implementation of Triangle and any hindrances I discovered.

The scanner was actually a very interesting aspect of the program to work with. I ran into the issue of the Dot Vname, which is used to gain access to members of records, which conflicted with my initial idea to access methods of an object. I eventually decided to use a minus sign or a dash, '-', to show when I was dealing with a class, as it did not interfere with any of my actual implementation. In the future, if this were to be expanded into a larger project, it would be important to have a proper way to delineate methods. I also added a new Token, TOKEN.class, which would delineate when I was using a class. This proved to be fortuitious in my work with the parser.

My ASTs for both the ClassTypeDenoter as well as the Method Call Command are seen in figures 1 and 2.

\begin{figure}[htbp]
\centerline{
    \mbox{\includegraphics[width=1.0in]{ctd_ast.pdf}}
  }
  \caption{ClassTypeDenoter AST}
  \label{fig:ctd_ast}
\end{figure}

\begin{figure}[htbp]
\centerline{
    \mbox{\includegraphics[width=2.0in]{mcc_ast.pdf}}
  }
  \caption{MethodCallCommand AST}
  \label{fig:mcc_ast}
\end{figure}

For my Parser, I made a few changes in the code, which can be seen in the appendix. Although I cut my teeth on the ClassTypeDenoter, the MethodCallCommand was the most difficult to implement, due to issues with the DotVname of records.

\subsection{Contextual Analyzer}
The visit method of the ClassTypeDenoter, as can be seen in the appendix, was easier than I'd hoped, with a simple visit to the Declaration AST making everything work out properly. The MethodCallCommand was a bit more involved, as I needed to be sure that I visited the first identifier, which was the object, followed by visiting the second identifier, which in this case is the method. After that, I needed to visit the parameters.

\subsection{Run-Time Organization and Code Generation}
Code Generation was a very involved process for classes, and consumed the most time for this project. I was following along with the code generation for the RecordTypeDenoter, which I knew I'd have to modify thanks to the addition of the more complicated Declaration for classes. Unfortunately, I could not discern the proper way to acutally get the generation to work.

Fortunately, Dr. Radenski pointed out that a new frame is needed in order for it to work properly. All that was needed was to create a new frame, and everything worked beautifully.
\subsection{Interpretation}
Fortunately, I did not need to work with the interpreter in my project. That was exceptional news, because it looked scary.

\section{Conclusions}
One of the coolest things about this project was being thrown into this crazy system that's already been implemented, then trying to figure out something fun to work on for a semester. As I mentioned in my presentation, one of the most important things I'd like to add is inheritance for objects. I think that is something that's integral to the general usage of classes, and is sorely missing from my implementation. However, one very practical thing I was able to implement for this project was keeping my ideas within the scope of the remaining time and my abilities. After several semesters of projects, I think this is the first time that I felt like I was really about to gauge a project and get a working implementation that I felt matched my goals as time and issues came to a close.
Overall, although I'm glad I'm finally finished with the beast that is the Compilers class, it has definitely been a great semester.

\bibliographystyle{h-physrev3.bst}
\bibliography{biblio}
The most helpful resource, aside from my class and professor, was from the ACM SIGPLAN\cite{130733}

\section*{Appendix}
\begin{lstlisting}[caption=Syntactic Analyzer - ClassTypeDenoter]
case Token.CLASS:
    accept(Token.CLASS);
    Declaration dAST = parseDeclaration();
    accept(Token.END);
    finish(typePos);
    typeAST = new ClassTypeDenoter(dAST, typePos);
  break;
\end{lstlisting}

\begin{lstlisting}[caption=Syntactic Analyzer - MethodCallCommand]
else if (currentToken.kind == Token.OPERATOR)
    acceptIt();
    Identifier iAST2 = parseIdentifier();
    accept(Token.LPAREN);
    ActualParameterSequence apsAST =
	 parseActualParameterSequence();
    accept(Token.RPAREN);
    commandAST = new MethodCallCommand(
	iAST, iAST2, apsAST, commandPos);
finish(commandPos);
\end{lstlisting}


\begin{lstlisting}[caption=Contextual Analyzer - ClassTypeDenoter]
public Object visitClassTypeDenoter(
	ClassTypeDenoter ast, Object o)
  ast.D.visit(this, null);
  return ast;
\end{lstlisting}

\begin{lstlisting}[caption=Contextual Analyzer - MethodCallCommand]
public Object visitMethodCallCommand(
	MethodCallCommand ast, Object o)
  Declaration binding = (Declaration) 
	ast.I2.visit(this, null);
  if (binding == null)
    reportUndeclared(ast.I);
  else if (binding instanceof 
	ProcDeclaration) 
    ast.APS.visit(this, (
	(ProcDeclaration) binding).FPS);
   else if (binding instanceof ProcFormalParameter) 
    ast.APS.visit(this, (
	(ProcFormalParameter) binding).FPS);
   else
    reporter.reportError("brutal.");
  return null;
\end{lstlisting}

\begin{lstlisting}[caption=Code Generation - ClassTypeDenoter]
public Object visitClassTypeDenoter(
	ClassTypeDenoter ast, Object o)
  int typeSize;
  if (ast.entity == null)
    typeSize = ((Integer) 
	ast.D.visit(this, new Frame (0, 0))).intValue();
    ast.entity = new TypeRepresentation(typeSize);
    writeTableDetails(ast);
   else
    typeSize = ast.entity.size;
  return new Integer(typeSize);
\end{lstlisting}

\begin{lstlisting}[caption=Code Generation - MethodCallCommand]
public Object visitMethodCallCommand(
	MethodCallCommand ast, Object o)
  Frame frame = (Frame) o;
  Integer argsSize = (Integer) ast.APS.visit(this, frame);
  ast.I2.visit(this, new Frame(frame.level, argsSize));
  return null;
\end{lstlisting}

\begin{lstlisting}[caption=Disassembler]
****** TAM Disassembler (Sun Version 2.1) ******
0:  PUSH        1
1:  JUMP        5[CB]
2:  LOAD  (1)   -1[LB]
3:  STORE (1)   0[SB]
4:  RETURN(0)   1
5:  JUMP        9[CB]
6:  LOAD  (1)   0[SB]
7:  CALL        putint
8:  RETURN(0)   0
9:  PUSH        1
10:  LOADL       7
11:  CALL  (SB)  2[CB]
12:  CALL  (SB)  6[CB]
13:  POP   (0)   1
14:  HALT  
\end{lstlisting}

\end{document}
